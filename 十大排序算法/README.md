# 此项目用c++实现十大排序算法

## 分类

<img width="397" alt="排序分类" src="https://user-images.githubusercontent.com/66712995/120634003-5cc11780-c49d-11eb-915f-8582169e9ef7.png">


## 按排序依据原则分类（普遍流行）：

![按排序依据原则分类](https://user-images.githubusercontent.com/66712995/120634035-664a7f80-c49d-11eb-94a4-234c48514812.png)


## 各排序算法比较

<img width="1251" alt="表格" src="https://user-images.githubusercontent.com/66712995/120634062-6c406080-c49d-11eb-9be8-98e6bb62e4d1.png">


### ==插入排序==

* 基本思想：边插入边排序，保证子序列中随时都是排好序的。
* 按插入位置方法的不同分类：1)顺序法：直接插入排序 2)二分法：折半插入排序 3)缩小增量：希尔排序
1. ==直接插入排序==

**原理**：从第二位数据开始， 当前数（第一趟是第二位数）与前面的数依次比较，如果前面的数大于当前数，则将这个数放在当前数的位置上，当前数的下标-1，直到当前数不大于前面的某一个数为止，直到遍历至最后一位元素。

2. ==折半插入排序==

**原理**：采用二分法在直接插入排序基础上进行查找插入

3. ==希尔排序==

**原理**：希尔排序是插入排序改良的算法，是插入排序的一种更高效的改进版本，也称递减增量排序，但是非稳定排序算法。希尔排序步长从大到小调整，先将整个待排序记录序列分割成为若干子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。所以步长是关键，最终步长为1，做最后的排序。

### ==交换排序==

* 基本思想：两两交换，如果发生逆序则交换，直到所有记录都排好序为止
* 常见的交换排序方法：1) 冒泡排序 2)快速排序

1. ==冒泡排序==

原理：每趟不断将记录两两比较，并按“前小后大”或者“前大后小”规则交换。具体的说就是重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。把最小的数浮上来，或者把最大的数据沉下去。

2. ==快速排序==

原理：任取一个元素(第一个)为中心点，所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子数组，对各子数组重新选择中心元素并依此规则调整，直到每个子数组的元素只剩一个。

### ==选择排序==

1. ==简单选择排序==

原理：在待排序的数据中选出最小(大)的元素放在其最终的位置。这里以从小到大排序为例，具体操作是首先通过n-1次比较，从n个数中找出最小数，将它和第一个元素交换，然后通过n-2次比较，从剩余n-1个数中找最小数，将它和第二个数交换，重复上述过程，共进行n-1趟排序，排序结束。

2. ==堆排序==

原理：分为两点，第一是堆排序，若在输出堆顶的最小值(最大值)后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小(大)值，如此反复，便能得到一个有序序列，这个过程称之为堆排序。第二是堆调整，以小根堆为例，输出堆顶元素之后，以堆中最后一个元素替代之，然后将根节点值与左右子树的根节点值进行比较，并与其中小者进行交换，重复上述步骤，直到叶子节点，将得到新的堆，称这个从堆顶到叶子的调整过程为“筛选”。

### ==归并排序==

原理：把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

### ==计数排序==

原理：当待排序的数的值都是在一定的范围内的整数时，可以用待排序的数作为计数数组的下标，统计每个数的个数，然后依次输出即可。

### ==桶排序==

原理：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。具体的说是每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。

### ==基数排序==

原理：设置若干个箱子，将关键字为k的记录放入第k个箱子(按照个位、十位、百位等的数字为关键字)，然后再按序号将非空箱子中的记录收集起来，循环往复直至排序完成。
